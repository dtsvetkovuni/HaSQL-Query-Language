let x = 34 in x + 17^C

take Names from Belejnici
remove Empty from Belejnici

select x1 x2 x3 x4 where exists z2 in exists z3 in exists z4 in A(x1 x2 x3 x4) and B(x1 z2 z3 z4)


select x1 x2 cont(afsfa) x3 const(145t435tryh)

x1!=const(e2rtrwee)


select x1 x2 where exists z in A (x1 z) and B (z x2);


show x1 z1 x1
from A(x1 x2) 
where x2!=empty & x3!=empty & z1=0;



show (x1,x2,x3,x4,x5)
where {
    R(x1,x2)
    R(x2,x3)
    R(x3,x4)
    R(x4,x5)
    x1=x5
};


conjunt R(x1 x2) R(x3 x4) R(x5 x6) R(x7 x8) = select x1 x2 x3 x4 x5
   where x1=x8
         x2=x3
         x4=x5
         x6=x7

do conjunt $A:2 $B:2 $C:2

where
get x1 x2 from A & x3 x4 from B

show a1,a2,a1 where A(a1) defin a2 = 0



||
&&
remove
take
from
=
<
>
(
)




--------------------error handling from 2.5.1----------------
--fixed spacing error on case of and fixed 'Ok'

data E a = Ok a | Failed String

thenE :: E a -> (a -> E b) -> E b
m `thenE` k = case m of 
     Ok a -> k a
     Failed e -> Failed e

returnE :: a -> E a
returnE a = Ok a

failE :: String -> E a
failE err = Failed err

catchE :: E a -> (String -> E a) -> E a
catchE m k = case m of
    Ok a -> Ok a
    Failed e -> k e

parseError :: [Token] -> a
parseError [] = error "Unknown Parse Error" 
parseError (t:ts) = error ("Parse error at line:column " ++ (tokenPosn t))
parseError tokens = failE "Parse error"








import Data.List
import Lexer ( alexScanTokens )
import System.Environment ( getArgs )
import Control.Exception ( catch, ErrorCall )
import System.IO

main :: IO ()
main = catch main' noLex

main' = do (fileName : _ ) <- getArgs 
           sourceText <- readFile fileName
           putStrLn ("Lexing : " ++ sourceText)
           let lexedProg = alexScanTokens sourceText
           putStrLn ("Lexed as " ++ (show lexedProg))

noLex :: ErrorCall -> IO ()
noLex e = do let err =  show e
             hPutStr stderr ("Problem with Lexing : " ++ err)
             return ()

-------------------------------------------------
factorial :: Int -> Double
factorial 0 = 1.0
factorial 1 = 1.0
factorial n = fromIntegral(n) * factorial (n - 1)

doubfact :: Int -> Double
doubfact 0 = 1.0
doubfact 1 = 1.0
doubfact n = fromIntegral(n) * doubfact (n - 2)

calcPi :: Int -> Int -> [Double] -> [Double]
calcPi n k acc | k>(n-1) = acc
               | otherwise = (form:calcPi n (k+1) acc)
   where form = (factorial k) / (doubfact (2*k+1))

approxPi :: Int -> Double
approxPi n | n<=0 = error "Not valid number"
           | otherwise = 2 * sum (calcPi n 0 [])



--------------------error handling from 2.5.1----------------
--fixed spacing error on 'case of' and fixed 'Ok'

data E a = Ok a | Failed String

thenE :: E a -> (a -> E b) -> E b
m `thenE` k = case m of 
     Ok a -> k a
     Failed e -> Failed e

returnE :: a -> E a
returnE a = Ok a

failE :: String -> E a
failE err = Failed err

catchE :: E a -> (String -> E a) -> E a
catchE m k = case m of
    Ok a -> Ok a
    Failed e -> k e





tokenPosn :: Token -> String
tokenPosn (TokenInt  (AlexPn a l c) n) = show(l) ++ ":" ++ show(c) ++ " With " ++ show(n)
tokenPosn (TokenVar  (AlexPn a l c) x) = show(l) ++ ":" ++ show(c) ++ " With " ++ x
tokenPosn (TokenString  (AlexPn a l c) x) = show(l) ++ ":" ++ show(c) ++ " With " ++ x
tokenPosn (TokenShow (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ "show"
tokenPosn (TokenWhere  (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ "where"
tokenPosn (TokenEmpty  (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ "empty"
tokenPosn (TokenAnd (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ "&"
tokenPosn (TokenSkip (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ "_"
tokenPosn (TokenEq (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ "="
tokenPosn (TokenNEq (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ "!="
tokenPosn (TokenLParen (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ "("
tokenPosn (TokenRParen (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ ")"
tokenPosn (TokenSeparator (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ ","
tokenPosn (TokenQuote (AlexPn a l c)) = show(l) ++ ":" ++ show(c) ++ " With " ++ """






-----------------------------FIleReader--------------------------------
fileMZip :: String -> Int -> IO ()
fileMZip str n = catch ( fileMZip' str n ) filehandler

filehandler :: IOException -> IO ()
filehandler e = do let errMsg = show (e :: IOException)
                   hPutStr stderr ("Warning - File not found : " ++ errMsg)
                   return ()

multiZipL :: [[a]] -> [[a]]
multiZipL [] = []
multiZipL ([] : xss) = multiZipL xss
multiZipL ((x:xs) : xss) = (x : [h | (h:_) <- xss]) : multiZipL (xs : [ t | (_:t) <- xss])

fileMZip' :: String -> Int -> IO ()
fileMZip' str n = do
  s <- readFile (str ++ ".csv")
  let ls = lines s
  let sss = map (splitOn ',') ls
--  let iss = map (map read) sss :: [[Int]]
  let mss = multiZipL sss
--  let oss = map (map show) mss
  let css = intercalate "\n" (map (intercalate ",") mss)
  writeFile "testout.csv" css
  
splitOn :: Char -> String -> [String]
splitOn c [] = []
splitOn c ls = takeWhile (/=c) ls : splitOn' c (dropWhile (/=c) ls)
 where splitOn' c [] = []
       splitOn' c [x] | x==c = [[]]
       splitOn' c (x:xs) | x==c = splitOn c xs
                         | otherwise = []




--SplitOn function from lectures used in Data.List.Split
splitOn :: Char -> String -> [String]
splitOn c [] = []
splitOn c ls = takeWhile (/=c) ls : splitOn' c (dropWhile (/=c) ls)
 where splitOn' c [] = []
       splitOn' c [x] | x==c = [[]]
       splitOn' c (x:xs) | x==c = splitOn c xs
                         | otherwise = []